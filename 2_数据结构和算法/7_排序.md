#### 7.排序（Sorting）

* ##### 7.1 方法

  * 选择排序法（Selection Sort）

    * 原理
      * 每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置
      * 然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾
      * 以此类推，直到全部待排序的数据元素排完
    * 不稳定排序
    * 效率
      * 空间：O(1)
      * 时间：O(n^2)

  * 堆排序（Heap Sort）

    * 原理
      * 在堆的数据结构中，堆中的最大值总是位于根节点（在优先队列中使用堆的话堆中的最小值位于根节点）
      * 最大堆调整（Max Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点
      * 创建最大堆（Build Max Heap）：将堆中的所有数据重新排序
      * 堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算
    * 不稳定排序
    * 效率
      * 空间：O(1)
      * 时间：O(n logn)

  * 冒泡排序 (Bubble Sort)

    * 原理
      * 比较相邻的元素。如果第一个比第二个大，就交换他们两个
      * 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数
      * 针对所有的元素重复以上的步骤，除了最后一个
      * 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较
    * 稳定排序
    * 效率
      * 空间：O(1)
      * 时间：O(n^2)

  * 插入排序法（Insertion Sort）

    * 原理
      * 将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增1的有序表
      * 使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动
    * 稳定排序
    * 效率
      * 空间：O(1)
      * 时间：O(n^2)

  * 希尔排序（Shell Sort）

    * 原理
      * 是直接插入排序算法的一种更高效的改进版本
      * 把记录按下标的一定增量分组，对每组使用直接插入排序算法排序
      * 随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止
    * 不稳定排序
    * 效率
      * 空间：O(1)
      * 时间：小于等于 O(n^2)

  * 归并排序（Merge Sort）

    * 原理
      * 将已有序的子序列合并，得到完全有序的序列
      * 即先使每个子序列有序，再使子序列段间有序
      * 若将两个有序表合并成一个有序表，称为二路归并
    * 稳定排序
    * 效率
      * 空间：O(n)
      * 时间：O(n logn)

  * 树排序（Tree Sort）

    * 原理
      * 首先对n个记录的关键字进行两两比较，然后在n/2个较小者之间再进行两两比较
      * 如此重复，直至选出最小的记录为止
    * 不稳定排序
    * 效率
      * 空间：O(n)
      * 时间：平均 O(n logn)

    * 伪码

      ```pseudocode
      make a[0] the root of a BST
      for i <- 1,...,n-1 do
      	if a[i] < a[0]
      		insert a[i] to the left-subtree of BST
          else
          	insert a[i] to the right-subtree of BST
      end for
      in-order traversal of left-subtree,
      then root, then right-subtree
      ```

  * 快速排序（Quick Sort）

    * 是对冒泡排序算法的一种改进
    * 原理
      * 首先设定一个分界值，通过该分界值将数组分成左右两部分
      * 将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值
      * 然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理
      * 重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了
    * 不稳定排序
    * 效率
      * 空间：O(logn)
      * 时间：O(n logn)

    * 伪码

      ```pseudocode
      name a[0] the pivot
      for i <- 1,...,n-1 do
      	if a[i] < a[0]
      		put a[i] to the left pile of the pivot
          else
          	put a[i] to the right pile of the pivot
      end for
      output quick-sorted left;
      output a[0]; output quick-sorted right
      ```

