#### 5.树（Tree）

* ##### 5.1 概述

  * 分层访问 Hierarchical access

  * 定义

    * 递归定义 Recursive definition

      * T = (root; T1, T2, T3, ..., Tn)

    * 终止条件 Termination condition

      * T1 = (sub-root; T11, T12, ..., T1n)
      * Tterm = (root; xxx)

    * 深度 Depth/Level

    * 高度 Height

    * 复杂度 Degree

    * Node

      * Root node

      * Internal node

      * External node/Leaf node

        

      * Parent node

      * Sibling node

      * Children node

  * 二叉树 Binary tree

    * child <= 2
    * degree <= 2
    * ordered
    * 节点个数（h 层）
      * 最少：h+1
      * 最多：2^(h+1)-1
      * 节点个数 n 范围：h+1  <=  n  <=  2^(h+1)-1
      * 深度 h 的范围：lg(n+1)  <=  h  <=  n-1
    * 满二叉树
    * 完全二叉树
      * 编号：1、10、11、100、101、110、111
      * 先序遍历：1、10、100、101、11、110、111
      * 中序遍历：100、10、101、1、110、11、111
      * 后序遍历：100、101、10、110、111、11、1
      * 层序遍历：1、10、11、100、101、110、111
    * Heap sort

  * 函数

    ```pseudocode
    func constructTree(data)
    	if data empty
    		return null
    	else
    		create root node from data[0]
    		partition data to n sets
    		for i = 1 to n
    			T[i] = constructTree(i-th partition of data)
    		link root to T[i]'s 
    		return address of root node
    		
    // （3）*（（5）+（7））
    InfixPrint(T)
    {
    	// stopping
    	if (isLeaf(T))
    		print(T.data)
    	else {
    	// recursion
    		print("(")
    		InfixPrint(T.left);
    		print(")")
    		print(T.data)
    		print("(")
    		InfixPrint(T.right)
    		print(")")
    	}
    }
    
    PostfixPrint(T)
    {
    	// stopping
    	if (isLeaf(T))
    		print(T.data)
    	else {
    	// recursion
    		InfixPrint(T.left);
    		InfixPrint(T.right)
    		print(T.data)
    	}
    }
    ```
    
    





























































